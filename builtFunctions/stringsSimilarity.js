// funcões para similaridade de frases por distância de Levenshteinfunction editDistance(s1, s2) {  s1 = s1.toLowerCase();  s2 = s2.toLowerCase();  var costs = new Array();  for (var i = 0; i <= s1.length; i++) {    var lastValue = i;    for (var j = 0; j <= s2.length; j++) {      if (i == 0)        costs[j] = j;      else {        if (j > 0) {          var newValue = costs[j - 1];          if (s1.charAt(i - 1) != s2.charAt(j - 1))            newValue = Math.min(Math.min(newValue, lastValue),              costs[j]) + 1;          costs[j - 1] = lastValue;          lastValue = newValue;        }      }    }    if (i > 0)      costs[s2.length] = lastValue;  }  return costs[s2.length];}function similarity(s1, s2) {  var longer = s1;  var shorter = s2;  if (s1.length < s2.length) {    longer = s2;    shorter = s1;  }  var longerLength = longer.length;  if (longerLength == 0) {    return 1.0;  }  return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);}// funcões para similaridade de frases por distância de Cosseno   function termFreqMap(str) {    var words = str.split(' ');    var termFreq = {};    words.forEach(function(w) {        termFreq[w] = (termFreq[w] || 0) + 1;    });    return termFreq;}function addKeysToDict(map, dict) {    for (var key in map) {        dict[key] = true;    }}function termFreqMapToVector(map, dict) {    var termFreqVector = [];    for (var term in dict) {        termFreqVector.push(map[term] || 0);    }    return termFreqVector;}function vecDotProduct(vecA, vecB) {    var product = 0;    for (var i = 0; i < vecA.length; i++) {        product += vecA[i] * vecB[i];    }    return product;}function vecMagnitude(vec) {    var sum = 0;    for (var i = 0; i < vec.length; i++) {        sum += vec[i] * vec[i];    }    return Math.sqrt(sum);}function cosineSimilarity(vecA, vecB) {    return vecDotProduct(vecA, vecB) / (vecMagnitude(vecA) * vecMagnitude(vecB));}var Cosinesimilarity = function textCosineSimilarity(strA, strB) {    var termFreqA = termFreqMap(strA);    var termFreqB = termFreqMap(strB);    var dict = {};    addKeysToDict(termFreqA, dict);    addKeysToDict(termFreqB, dict);    var termFreqVecA = termFreqMapToVector(termFreqA, dict);    var termFreqVecB = termFreqMapToVector(termFreqB, dict);    return cosineSimilarity(termFreqVecA, termFreqVecB);}// funcões para similaridade de frases por Jaro-Winklervar JaroWrinker  = function (s1, s2) {    var m = 0;        // Exit early if either are empty.    if ( s1.length === 0 || s2.length === 0 ) {        return 0;    }        // Exit early if they're an exact match.    if ( s1 === s2 ) {        return 1;    }        var range     = (Math.floor(Math.max(s1.length, s2.length) / 2)) - 1,        s1Matches = new Array(s1.length),        s2Matches = new Array(s2.length);        for ( i = 0; i < s1.length; i++ ) {        var low  = (i >= range) ? i - range : 0,            high = (i + range <= s2.length) ? (i + range) : (s2.length - 1);            for ( j = low; j <= high; j++ ) {        if ( s1Matches[i] !== true && s2Matches[j] !== true && s1[i] === s2[j] ) {            ++m;            s1Matches[i] = s2Matches[j] = true;            break;        }        }    }        // Exit early if no matches were found.    if ( m === 0 ) {        return 0;    }        // Count the transpositions.    var k = n_trans = 0;        for ( i = 0; i < s1.length; i++ ) {        if ( s1Matches[i] === true ) {        for ( j = k; j < s2.length; j++ ) {            if ( s2Matches[j] === true ) {            k = j + 1;            break;            }        }            if ( s1[i] !== s2[j] ) {            ++n_trans;        }        }    }        var weight = (m / s1.length + m / s2.length + (m - (n_trans / 2)) / m) / 3,        l      = 0,        p      = 0.1;        if ( weight > 0.7 ) {        while ( s1[l] === s2[l] && l < 4 ) {        ++l;        }        weight = weight + l * p * (1 - weight);    }    return weight;}